# Week 1
------------------------------------------
# คำอธิบายของแต่ละไฟล์
arrays-inclass.js => เป็นไฟล์ที่เก็บ Lecture ในคลาส
arrays02-inclass.js => เป็นไฟล์ที่เก็บ Lecture ในคลาส (เหมือนกัน)
------------------------------------------

ในสัปดาห์แรกๆ จะทำการทวนเนื้อหา 3 ส่วนหลักๆ คือ arrays, objects, functions

Arrays
--------------------------
array นั้นเป็นโครงสร้างข้อมูลแบบเป็นลำดับ ซึ่งเริ่ม index จาก 0
เก็บค่าต่างชนิดกันได้ อย่างเช่น number, string, object และอื่นๆ
ซึ่งตัว array นั้นมันเป็น Dynamic (คือสามารถเพิ่มลดขนาดได้)

Objects
--------------------------
เป็นชุดที่มี {key: value}
ซึ่งค่า value อาจจะเป็น primitive, array, หรือแม้กระทั่ง function และเป็น Dynamic เหมือนกัน

Functions
-------------------------
Function คิดง่ายๆ เป็นกล่องที่เราสามารถ Reuser ได้ซ้ำเรื่อยๆๆๆ
และมีสามแบบ
Function Declaration
---
ฟังก์ชันแบบประกาศ
function sayHello(name) {
  return `Hello, ${name}!`;
}

console.log(sayHello("Chayanon"));

Function Expression
---
ฟังก์ชั่นแบบเก็บไว้ในตัวแปร
const sayHi = function(name) {
  return `Hi, ${name}!`;
};

console.log(sayHi("Chayanon"));

Arrow Function
---
ฟังก์ชั่นแบบสั้นกระจิดริด
const greet = (name) => {
  return `Greetings, ${name}!`;
};

console.log(greet("Chayanon"));
===================================================

# Week 2
------------------------------------------
# คำอธิบายของแต่ละไฟล์
object-comparision.js => เป็นไฟล์สำหรับเก็ขโจทย์ที่ฝึกฝนส่วนตัว
object.inclass.js => เป็นไฟล์ที่เก็บ Lecture ในคลาส
shallow_equality.js => ไฟล์ที่อาจารย์ให้ไปฝึกเป็น Self-Practice เขียนทำความเข้าใจ
------------------------------------------

ทำไมถึงเกิด Shallow Eqaulity ขึ้นมา
-----------------------------
จริงอยู่ที่ว่า Deep Eqaulity นั้นจะตรวจสสอบลึก แต่ที่มันเมีขึ้นมาเพราะจะเกี่ยวกับเรื่องของ Performance
และความเหมาะสมของงานนั้นๆ ที่จะต้องใช้ เช่นงานที่มันไม่ได้จำเป็นต้องละเอียดลึกขนาดนั้น

ทำไมถึงเกิด Deep Eqaulity ขึ้นมา
------------------------------
เนื่องจากข้อจำกัดของ Shallow Eqaulity ที่มันไม่สามารถเช็ค Object ซ้อน Object ได้
มีความแม่นยำกว่า แต่ช้าเป็นเต่าอึดกว่านิดนหน่อย เพราะต้องไล่เช็คทุกขั้นตอน ซึ่งในกรณีที่หาก Object มันมีขนาดใหญ่เท่าหอไอเฟล 
จะส่งผลต่อ Performance ที่ Shallow Eqaulity นั้นทำได้ดีกว่าได้

แล้ว...อันไหนดีกว่า!? ว่าตามตรงคงแล้วแต่ Use case นั้นๆ แค่ผมให้ว่าผู้ชนะได้แก่ Deep Eqaulity
เพราะมันมีความสามารถในการเช็กลึกกว่าว่า Object ทั้งหมดมีโครงสร้างและค่าตรงกันจริงๆ (เน้นความถูกต้องมากกว่าเร็ว)

เพิ่มเติม: ในไฟล์ของ object-comparision.js ผมได้เขียนคำอธิบายโค๊ดไว้ด้วยครับ เนื่องจากเป็นการอธิบายตามความเข้าใจผมในแต่ละบรรทัด
เลยอาจจะไม่มีในนี้ครับ

===================================================
# Week 3
-----------------------------------
function-inclass.js => ไฟล์จดบันทึก Functional ในคาบ
function-practice.js => โจทย์ที่อาจารย์ให้มาทำทดสอบ
functionTest-inclass.js => ทดสอบฝึกเกี่ยวกับฟังก์ชี่นในคาบ
-----------------------------------

function-practice.js 
จากโจทย์ของอาจารย์ มีเงื่อนไขที่ว่าจะต้องรับ input เป็น string และคืนค่าเป็น object ที่เก็บคำซ้ำและจำนวนของคำ
ซึ่งต้องแปลงทั้งหมดเป็น lowercase ทำให้ผมได้ทดลองเขียนออกมาและสรุปเป็นดังนี้ครับ

ก่อนอื่นภายในฟังก์ชั่นผมจะทำการเช็คก่อนว่าค่าที่เข้ามาเป็น String ไหมเพื่อป้องกัน error หากไม่ใช่ค่อยให้ return underfined

if (typeof sententce !== 'string') {
    return undefined
}

ต่อมาผมจะทำการแปลงข้อความ
โดยที่จะปรับเป็น Lowercase หรือเปลี่ยนเป็นตัวเล็กทั้งหมดก่อน จากนั้นจะใช้ trim เพื่อลบช่องว่างด้านหน้าหลังข้อความ
ในส่วนของ split(/\s+/) คือผมจะแยกค่าโดยใช้ Regex (ลองไปหาดูตามในเน็ตมาครับ พวก Stackoverflow) 
ยกตัวอย่างแบบเห็นภาพคือ จาก "Do it" จะเป็น ["Do", "it"]

const words = sententce
  .toLowerCase()
  .trim()
  .split(/\s+/);

ส่วนต่อมาผมได้ใช้ .reduce() เพื่อสะสมค่าจำนวนคำในการวนลูปหาค่าใน Array 
เพื่อเช็คว่าถ้ายังไม่มี word ใน object จะเริ่มจาก 0 แล้ว +1

return words.reduce((acc, word) => {
    acc[word] = (acc[word] || 0) + 1;
    return acc;
}, {});

ตัวอย่างแบบเห็นภาพมากกว่านี้ เพราะผมอธิบายงงคือ
// ครั้งที่ 1: {do: 1}
// ครั้งที่ 2: {do: 1, it: 1}
// ครั้งที่ 3: {do: 2, it: 1}

===================================================
# Week 4
----------------------------------------------------------
# คำอธิบายของแต่ละไฟล์
- solution.js => ไฟล์ Practices ที่ทดลองฝึกทำเอง
- solution.test.js => Testcases สำหรับ solution.js
- array_methods.js => โจทย์ที่เขียนทดสอบตามในห้องเรียน
- throw.js => ฝึกทดลองใช้ Error Handling โดย try..catch & throw
----------------------------------------------------------

สัปดาห์นี้ด้วยความที่ว่าอาจารย์ได้มีการให้ GitHub Classroom มาทดลองทำ แล้วมี Testcases ให้มาด้วย ผมเลยอยาก
จำลองทำเหมือนอาจารย์ดูว่าถ้าอยากจะลองทำ Testcases แบบอาจารย์ต้องทำอย่างไร เผื่อที่ว่าจะได้เป็นการฝึกทดลอง
ให้มันเหมือนสภาพแวดล้อมในห้องสอบไปในตัว
นั้นเป็นเหตุผลทำให้เกิดไฟล์ solution.test.js ขึ้นมาครับผม (รันโดย npx jest)

จากการทดลองฝึกในไฟล์ solution.js ที่ผมให้ ChatGPT ช่วยเจนโจทย์ออกมาให้ที่มีเนื้อหาเกี่ยวกับ Arrays Methods + Testcases ออกมาดู 
ทำให้ผมเริ่มพอเห็ตภาพ Logic การทำงานของ Methods มากขึ้นว่าอันไหนควรมาก่อนหน้าก่อนหลัง แล้วจะได้ Output ที่แตกต่างกันอย่างไรหากมีการสลับ Methods
ซึ่งผมขอยอมรับส่วนนึงว่า มีบางข้อที่ผมมึนๆ แล้วทำไม่ได้ เลยแอบเปิดเฉลยดูนิดหน่อย 1-2 ข้อ แต่ที่เหลือคือทดลองรันหลายๆ รอบจนกว่าจะผ่าน Testcases
และให้ AI ช่วยตรวจสอบโค๊ดให้ดูด้วยครับ ว่าโค๊ดที่ผมเขียนนั้นถือว่าเป็น "โค๊ดที่ดี" และตรงตามความต้องการของโจทย์หรือเปล่า (Evalution เกิดหลังจากที่ผมรันผ่านนะครับ 
เพราะว่าบางตัว AI มันก็แจ้งผมมาเหมือนกันว่าผม Hardcode แต่ตอนนี้แก้เรียบร้อยครับ)

หลักๆ ที่ผมรู้สึกเข้าใจ Array Method มากขึ้นคือตัวของ .map(), .filter(), .reduce(), .sort() ครับ รวมถึงวิธีการเขียนแบบ
Functional Programming เพิ่มเติมด้วย ส่วนตัวอื่นๆ อาจจะไม่มีในโจทย์เลยต้องไปฝึกเพิ่มเติมครับผม

คำเตือน: เนื่องจากมันมีไฟล์ node_modules ที่มีขนาดใหญ่มาก ผมเลยจำเป็นต้องลยออกไปครับ
===================================================
# Week 5
------------------------------------------
# คำอธิบายของแต่ละไฟล์
arrMethodtest.js => ไฟล์ Arr Methods ที่ต่อมาจากสัปดาห์ก่อน 
esModuleTest.js => แสดงค่า Output
userModule.js => รับฟังก์ชั่นไปประมวลผลแล้วแสดง output
util.js => เขียนฟังก์ชั่นแล้ว export module ออกไป
utitly.js => เขียนฟังก์ชั่นแล้ว export module ออกไป
index.html => ไฟล์ที่จะแสดงผลในหน้าบ้าน
practice.js => Pratcies ภายในห้อง
------------------------------------------

เนื่องจากจำนวนไฟล์ที่เยอะ ผมขอทำการสรุปสิ่งที่อาจารย์สอนตามที่ผมเข้าใจดีกว่าครับ
Module เป็นการแบ่งโค๊ดออกเป็นส่วนย่อยๆๆ ที่เราสามารถนำกลับมาใช่ได้ซ้ำ
ทำให้โค๊ดดูจัดแยกเป็นสัดส่วนชัดเจน เพื่อง่ายต่อการดูแล

Tree Shaking
เขย่าต้นไม้ คือการลบโค๊ดที่ไม่จำเป็นออก (Dead Code) ซึ่งอาศัย
import กับ export เพื่อระบุว่าใช้โค๊ดไหน ทำให้ไฟล์เล็กลงและดูหล่อ ดูสะอาดดดดด มากขึ้น

ซึ่งตัวของ JS Modules จะมีอยู่หลายประเภทอันตั้งแต่
CommonJS ใช้ใน Node.js โดย require() กับ module.exports
หรือ ESM ใช้ตัวของ import, export
===================================================
